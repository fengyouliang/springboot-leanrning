# How：落地方案（章节学习卡片 + 渐进式全量改写）

## 1) 核心设计：章节学习卡片（五问闭环）

在每个章节标题 `# ...` 之后，统一插入一个“学习卡片”区块，用最短信息回答五个问题（读者第一屏就知道该怎么读/跑/查源码）：

- **知识点**：一句话定义边界（这章解决什么问题，不解决什么）
- **怎么用**：给出最常见的使用方式（注解/配置/调用方式），用步骤或最小示例描述
- **原理**：给出主线与关键分支（调用链/生命周期/拦截链/时机差异），避免堆概念
- **源码入口**：列出关键类/关键方法/建议断点（Spring/Spring Boot + 本仓库示例）
- **加深理解的 Lab**：推荐 1 个可跑 Lab（必要时补 1 个对照 Lab）

### 学习卡片推荐形态（与现有 MkDocs 风格一致）

- 使用 admonition（例如 `!!! summary` / `!!! info`），保持站点渲染一致性
- 卡片内容控制在“可扫读”的 5–10 行，正文继续承载叙事与细节

## 2) 章节内容的“书籍化”改写策略（不推倒重写）

全量章节数量很大（174+），因此采用“先补齐五问，再逐步优化叙事”的渐进策略：

1. **第一轮（覆盖优先）**：只做“章首学习卡片”+ 必要的开场改写（把问题说清楚）
2. **第二轮（体验优先）**：对核心主线章节做叙事增强（主线时间线、读者检查点、证据链观察点）
3. **第三轮（深挖优先）**：补齐更稳定的“源码入口”（关键类/关键方法/断点锚点），避免泛泛而谈

> 这样可以保证：即便只完成第一轮，读者也能“知道学什么/怎么跑/去哪看源码”，并且能持续迭代。

## 3) “源码是什么”的统一口径（避免失真）

每章源码入口至少覆盖两类：

1. **框架源码（Spring/Spring Boot）**：关键抽象/关键实现/关键算法的入口类与方法名（便于断点与检索）
2. **仓库源码（示例/测试）**：本仓库对应的 `src/main/java` 或 `src/test/java` 入口（把原理落到可复现证据）

避免在文档里绑定不稳定信息：

- 不写行号（易漂移）
- 不写“打开源码看一下”这种模糊指引，必须给到可定位的类/方法名

## 4) “哪个 Lab 加深理解”的选择规则（每章至少 1 个）

优先级建议：

1. 章节正文或尾部已存在的 `*LabTest`（直接采用，保持一致）
2. 模块主线时间线推荐的默认 Lab（作为兜底）
3. 若章节是对照/边界类主题，补 1 个对照 Lab（正例/反例、或 mainline/pitfall）

## 5) 自动化与闸门（让“全量改写”可管理）

为避免“改了很多章但漏了几章”，需要补齐两类工具：

1. **清单生成**：从各模块 `docs/README.md`（SSOT）生成全量章节清单与进度表（可在方案包内维护）
2. **一致性检查**：新增脚本检查每个章节是否包含学习卡片的五个字段，并接入 `scripts/check-docs.sh`

这样可以做到“章节数越多，越不依赖人工记忆”。

## 6) 推进顺序（按主线优先 + 风险可控）

建议按学习主线顺序批量推进（每批 1–3 个模块），每批都跑一次闸门与 strict build：

1. Boot Basics → Beans → AOP → Tx → Web MVC
2. Security → Data JPA → Cache → Async/Scheduling → Events
3. Resources → Profiles → Validation → Actuator/Observability → Web Client → Testing
4. Business Case 收束（最后用综合模块校验全链路叙事一致性）

每批完成后输出：

- 已覆盖章节数 / 总章节数
- 闸门结果（断链/构建/覆盖检查）
- 风格问题沉淀到 `docs/book-style.md`（作为写作 SSOT）
